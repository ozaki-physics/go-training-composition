# テスト駆動開発の練習
- 一気にテストする  
`go test ./trainingTest/...`  
- 任意のチャプターだけテストする  
`go test ./trainingTest/chapter01/...`  
- 任意のチャプターの任意のディレクトリだけテストする  
`go test ./trainingTest/chapter01/money/`  

## 参考文献 References
テスト駆動開発  
著者: Kent Beck  
訳者: 和田 卓人  
出版社: 株式会社オーム社  
2020/09/10: 第1版 第7刷  
2017/10/20: 第1版 第1刷  

### 目次 Table of contents
- Chapter01: 仮実装
- Chapter02: 明白な実装
- Chapter03: 三角測量
- Chapter04: 意図を語るテスト
- Chapter05: 原則をあえて破るとき
- Chapter06: テスト不足に気づいたら
- Chapter07: 疑念をテストに翻訳する
- Chapter08: 実装を隠す
- Chapter09: 歩幅の調整
- Chapter10: テストに聞いてみる
- Chapter11: 不要になったら消す
- Chapter12: 設計とメタファー
- Chapter13: 実装を導くテスト
- Chapter14: 学習用テストと回帰テスト
- Chapter15: テスト任せとコンパイラ任せ
- Chapter16: 将来の読み手を考えたテスト
- Chapter17: 多国通貨の全体ふりかえり

### Chapter01: 仮実装
最初に __TODO リスト__ を作る  
テストを書く  
気づいたことは TODO リストに加えていく  
最初はコンパイラを通す  
次に レッド を確認する  
TDD で大事なのは 細かいステップを踏み続けられること  

#### ふりかえり
- 書くべきテストのリストを作った
- どうなったら嬉しいかを小さいテストコードで表現した
- 空実装を使ってコンパイラを通した
- 大罪を犯しながらテストを通した
- 動くコードをだんだんと共通化し ベタ書きの値を変数に置き換えていった
- TODO リストに項目を追加するに留め 一度に多くのものを相手することを避けた

### Chapter02: 明白な実装
仮実装: コードでまずベタ書きの値を使い 実装を進めるに従って 徐々に変数に置き換えていく  
明白な実装: すぐに頭の中の実装をコードを落とす  

#### ふりかえり
- 設計の問題(今回は副作用)をテストコードに写し取り その問題点のせいでテストが失敗するのを確認した
- から実装でさっさとコンパイルを通した
- 正しいと思える実装をすぐに行い テストを通した

### Chapter03: 三角測量
Value Object パターン を使うメリットは 別名参照問題を回避できること  
別名参照問題: 2つのオブジェクトが同じ参照先を見ていて 片方で値を変えると もう片方の値も変わってしまう問題  

三角測量を真似て コードを一般化できるのは 2つ以上の実例があるときだけだと考えてみよう  
ただし テストコードとプロダクトコード間の重複は無視する  
三角測量はどうリファクタリングしていいか分からないとき や 自分の設計のどこが可動域として考えているかはっきりさせたいときに使える  

#### ふりかえり
- Value Object パターンを満たす条件が分かった
- その条件を満たすテストを書いた
- シンプルな実装を行った(まずは true を返すだけ)
- すぐにリファクタリングを行うのではなく もう1つテストを書いた(三角測量)
- 2つのテストを同時に通すリファクタリングを行った

### Chapter04: 意図を語るテスト
構造体同士の比較(Equals メソッド)を定義したから  
直接 構造体の中身の値同士を比較してたテストから 構造体同士を比較するテストに変更した  
等価性比較が正確に実装されていることを検証できていないなら かけ算のテストも検証できていないというリスクを受け入れた  
もし リスクを取ってうまくいかなかったら教訓にする  
ただ グリーンなのでリスクを取って進むことができる  

#### ふりかえり
- 作成したばかりの機能を使って テストを改善した
- そもそも正しく検証できていないテストが2つあったら もはやお手上げだと気づいた
- そのようなリスクを受け入れて先に進んだ
- テスト対象のオブジェクトの新しい機能を使い テストコードとプロダクトコードの結合度を下げた(値を取得するメソッドを private にした)

### Chapter05: 原則をあえて破るとき
フェーズのリズムは  
1. テストを書く
2. コンパイラを通す
3. テストを走らせ 失敗を確認する
4. テストを通す
5. 重複を排除する

各フェーズには フェーズなりの目的と解決法がある  
最初の3個のフェーズはなるべく速く通過して 新しい機能がどの状態にあるか分かるところまで行きたい  
そのため どのような罪を犯してもよい(コピー&ペースト など)  
ただ コピー&ペースト による再利用は 抽象化の敗北であり きれいな設計を殺すことになるので すぐにこの大罪を贖うこと  
コピー&ペースト をしたため 現状 Dollar と Franc は同じ構造体の形をしている

#### ふりかえり
- 大きなテストに立ち向かうにはまだ早かったので 次の一歩を進めるために小さなテストをひねり出した
- 恥知らずにも既存のテストをコピペして テストを作成した
- さらに恥知らずにも 既存のモデルコードをまるごとコピペして テストを通した
- この重複を排除するまでは 家に帰らないと心に決めた

### Chapter06: テスト不足に気づいたら
#### ふりかえり

### Chapter07: 疑念をテストに翻訳する
#### ふりかえり

### Chapter08: 実装を隠す
#### ふりかえり

### Chapter09: 歩幅の調整
#### ふりかえり

### Chapter10: テストに聞いてみる
#### ふりかえり

### Chapter11: 不要になったら消す
#### ふりかえり

### Chapter12: 設計とメタファー
#### ふりかえり

### Chapter13: 実装を導くテスト
#### ふりかえり

### Chapter14: 学習用テストと回帰テスト
#### ふりかえり

### Chapter15: テスト任せとコンパイラ任せ
#### ふりかえり

### Chapter16: 将来の読み手を考えたテスト
#### ふりかえり

### Chapter17: 多国通貨の全体ふりかえり
#### ふりかえり

### その他
TDD のゴールは __動作するきれいなコード__  

#### テスト駆動開発のルール
1. 自動化されたテストが失敗したときのみ 新しいコードを書く
2. 重複を除去する

#### 作業順序
1. レッド  
動作しない、 おそらく最初のうちはコンパイルも通らないテストを1つ書く  
2. グリーン  
そのテストを迅速に動作させる。 このステップでは罪を犯してもよい。  
3. リファクタリング  
テストを通すために発生した重複をすべて除去する  

#### TDD のリズム
1. まずはテストを1つ書く
2. すべてのテストを走らせ 新しいテストの失敗を確認する
3. 小さな変更を行う
4. すべてのテストを走らせ すべて成功することを確認する
5. リファクタリングを行って重複を除去する

#### 依存性と重複
テストコードとプロダクトコードの間にある重複が問題なのではない  
重複は ほとんどの場合コードの複数の場所に同じ表現が出てくるような ロジックの重複の形で発見される  
オブジェクトを使えば抽象化によってロジックの重複をきれいに取り除ける  
プログラムの重複を取り除くと 依存性も取り除かれる  

#### Value Object パターン
回避する方法
1. 依存しているオブジェクトを渡さない  
渡すときはコピーを渡す  
ただし 時間もメモリも消費するし 状態の共有ができなくなる  
2. Observer パターン  
オブジェクトへの依存を明示的に登録し 状態が変更されたら通知がくるようにする  
ただし 処理フローが追いにくく 依存の登録や解除ロジックは汚くなりがち  
3. Value Object パターン  
Value Object には コンストラクタで設定したインスタンス変数の値が変わってはならないという成約  
オブジェクトが Value Object であるためには 操作はすべて新しいオブジェクトを返さなければならない  
ただし パフォーマンスに問題が出る可能性はあるが 
パフォーマンス分析をするには実際のデータで リアルな利用パターンを試し プロファイリングを行ってからでないと 
__パフォーマンスを問題にする資格はない__  
Value Object を作る際は 等価性比較を実装しなければならない(かつ 多くのプログラミング言語においては ハッシュ化も実装しなければならない)  
インスタンスが異なっていることと オブジェクトが意味的に同じことなのは 関係がないから  
