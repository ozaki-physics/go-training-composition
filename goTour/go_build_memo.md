## Go での package の扱いを理解する
よく見る`package main`は何を意味しているのか?
他の go ファイルを import する方法

Go のプログラムはパッケージ(package)で構成されている
プログラムは main パッケージから開始される
プログラム実行時の処理開始位置の main パッケージあるいは main 関数を エントリポイント という
インポートパスが "math/rand" のパッケージは package rand ステートメントで始まるファイル群で構成される
main パッケージが大きくなってきた時、処理を複数の関数あるいはファイルに分割したい。
その時 import 文では 新しく作った独自パッケージへのパスとして $GOPATH/src 直下のディレクトリから パッケージファイル(*.go)の直上のディレクトリまでを指定する

Go Modules のとき importするパスは 自分のプロジェクトルートディレクトリ直下のディレクトリ名から importしたいパッケージの直上のディレクトリまで

Go Modules(vgo)を使うならばimportにて相対パスは使用不可なので絶対パスを指定しよう
import 自体は相対 path でも書けるが Go の初期が絶対 path しか使えなかったため 慣例的に絶対 path を使うらしい

わかったこと
- 対象ディレクトリ配下に複数のmainパッケージのモジュールを置く
→ エラー
`package main`のファイルは 1プロジェクトに1個っぽい
main にかけなくなった分のコードが外に出される
- 異なる名前のパッケージ宣言を持つモジュールを同じディレクトリの中に置く
→ エラー
1つのディレクトリの中にあるファイルの package ステートメントが異なっていたどき(片方 package hello01, 片方 package hello02)のとき コンパイルエラーになる

ディレクトリ名は goodnight でも`package hello`にすることができる
→ ディレクトリ名とパッケージ名は同じにしなくてよい
そのとき main ファイルで import するとき 記述は ディレクトリ名だが 実際に 〇〇.△△() で使うときは hello.△△() になる
混乱のもとになるので ディレクトリ名と同じ package 名にする
または
```go
import goodnight "github.com/〇〇/goodnight"
```
と import する package に別名, 別のラベルを付けると goodnight.△△() で使えるようになる

Go Modules の魅力は /go/src 以外のディレクトリでも go get して 異なるディレクトリにダウンロードできることかもしれない
始めは go mod init したら記録される path が基本の場所で そこから import の path を書いたらいいと思っていたけどそうじゃないみたい
package のバージョンやなんの package を使っているか管理できるだけで 基本は src から path 書かないといけないっぽい
あと これ以上は公式リファレンスを読まないといけないくて 時間対進捗が良くないと思われる
とりあえず Go Modules についてはここらへんにして 書籍が終わるまでは Go Modules 下(実質 GOPATH)で開発する
