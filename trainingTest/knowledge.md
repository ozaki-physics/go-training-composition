# テスト駆動開発の練習
- 一気にテストする  
`go test ./trainingTest/...`  
- 任意のチャプターだけテストする  
`go test ./trainingTest/chapter01/...`  
- 任意のチャプターの任意のディレクトリだけテストする  
`go test ./trainingTest/chapter01/money/`  

## 参考文献 References
テスト駆動開発  
著者: Kent Beck  
訳者: 和田 卓人  
出版社: 株式会社オーム社  
2020/09/10: 第1版 第7刷  
2017/10/20: 第1版 第1刷  

[テスト駆動開発(本)を Go 言語で取り組んでみる](https://qiita.com/eyuta/items/d18296d13aa68523f505)  
とても賢い方法で実装してあったりする  
1. 6章で 埋め込みを使いつつ Equals() の引数をインタフェースにする賢さ  
  埋め込みをすると型が変わっちゃうから扱いにくかったが インタフェースにすることで埋め込みにも対応した  
2. 7章で 書籍のように型を直接比較するのではなく 型のような意味を持った name を追加する賢さ  
  埋め込みやってるから単純に型を取得するだけでは 等しいことを表現できなかった  
3. 1つのファイルで差分を表現しつつ コミットログじゃない方法で各章のコードを残す方法に ブランチを使っている賢さ  
  僕は 各章でファイルとして分けたが 前の章との差分が分かりにくいし import の Chapter を変更忘れてハマることがあった  
  -> 各ブランチをマージすることで main ブランチは差分で各章を比較できるし ブランチ切り替えると 各章でのコードが見れる  
4. 8章で Equals() のレシーバ側の値の取り出し方が インタフェースの実装メソッドではなく 直接フィールドにアクセスしている賢さ  
  -> 引数との差別化ができて良い  
5. 書籍のように pair.go ファイルを作成せず bank.go に Pair struct を定義した賢い  
  -> なぜなら Java オブジェクトの equals は等値比較だが Go の struct の == は等価比較だから equals() や hashCode() をわざわざ定義しなくてよいから

### 目次 Table of contents
- Chapter01: 仮実装
- Chapter02: 明白な実装
- Chapter03: 三角測量
- Chapter04: 意図を語るテスト
- Chapter05: 原則をあえて破るとき
- Chapter06: テスト不足に気づいたら
- Chapter07: 疑念をテストに翻訳する
- Chapter08: 実装を隠す
- Chapter09: 歩幅の調整
- Chapter10: テストに聞いてみる
- Chapter11: 不要になったら消す
- Chapter12: 設計とメタファー
- Chapter13: 実装を導くテスト
- Chapter14: 学習用テストと回帰テスト
- Chapter15: テスト任せとコンパイラ任せ
- Chapter16: 将来の読み手を考えたテスト
- Chapter17: 多国通貨の全体ふりかえり
- その他
- デザインパターン

### Chapter01: 仮実装
最初に __TODO リスト__ を作る  
テストを書く  
気づいたことは TODO リストに加えていく  
最初はコンパイラを通す  
次に レッド を確認する  
TDD で大事なのは 細かいステップを踏み続けられること  

仮実装: コードでまずベタ書きの値を使い 実装を進めるに従って 徐々に変数に置き換えていく  
テストコードとプロダクトコードの重複を意図的に発生させて 開発を駆動するセンスに依存している  

#### ふりかえり
- 書くべきテストのリストを作った
- どうなったら嬉しいかを小さいテストコードで表現した
- 空実装を使ってコンパイラを通した
- 大罪を犯しながらテストを通した
- 動くコードをだんだんと共通化し ベタ書きの値を変数に置き換えていった
- TODO リストに項目を追加するに留め 一度に多くのものを相手することを避けた


### Chapter02: 明白な実装
明白な実装: すぐに頭の中の実装をコードを落とす  
仮実装や三角測量は 細かく刻んだ小さなステップだから 明白な実装だけで進めることができるなら それで良い  
明白な実装でうまくいかないときは 仮実装や三角測量を使う  

#### ふりかえり
- 設計の問題(今回は副作用)をテストコードに写し取り その問題点のせいでテストが失敗するのを確認した
- から実装でさっさとコンパイルを通した
- 正しいと思える実装をすぐに行い テストを通した


### Chapter03: 三角測量
Value Object パターン を使うメリットは 別名参照問題を回避できること  
別名参照問題: 2つのオブジェクトが同じ参照先を見ていて 片方で値を変えると もう片方の値も変わってしまう問題  

三角測量を真似て コードを一般化できるのは 2つ以上の実例があるときだけだと考えてみよう  
ただし テストコードとプロダクトコード間の重複は無視する  
三角測量はどうリファクタリングしていいか分からないとき や 自分の設計のどこが可動域として考えているかはっきりさせたいときに使える  
頭の中で 正しい一般化の方向が本当に分からないときに使う  

#### ふりかえり
- Value Object パターンを満たす条件が分かった
- その条件を満たすテストを書いた
- シンプルな実装を行った(まずは true を返すだけ)
- すぐにリファクタリングを行うのではなく もう1つテストを書いた(三角測量)
- 2つのテストを同時に通すリファクタリングを行った


### Chapter04: 意図を語るテスト
構造体同士の比較(Equals メソッド)を定義したから  
直接 構造体の中身の値同士を比較してたテストから 構造体同士を比較するテストに変更した  
等価性比較が正確に実装されていることを検証できていないなら かけ算のテストも検証できていないというリスクを受け入れた  
もし リスクを取ってうまくいかなかったら教訓にする  
ただ グリーンなのでリスクを取って進むことができる  

#### ふりかえり
- 作成したばかりの機能を使って テストを改善した
- そもそも正しく検証できていないテストが2つあったら もはやお手上げだと気づいた
- そのようなリスクを受け入れて先に進んだ
- テスト対象のオブジェクトの新しい機能を使い テストコードとプロダクトコードの結合度を下げた(値を取得するメソッドを private にした)


### Chapter05: 原則をあえて破るとき
フェーズのリズムは  
1. テストを書く
2. コンパイラを通す
3. テストを走らせ 失敗を確認する
4. テストを通す
5. 重複を排除する

各フェーズには フェーズなりの目的と解決法がある  
最初の3個のフェーズはなるべく速く通過して 新しい機能がどの状態にあるか分かるところまで行きたい  
そのため どのような罪を犯してもよい(コピー&ペースト など)  
ただ コピー&ペースト による再利用は 抽象化の敗北であり きれいな設計を殺すことになるので すぐにこの大罪を贖うこと  
コピー&ペースト をしたため 現状 Dollar と Franc は同じ構造体の形をしている

#### ふりかえり
- 大きなテストに立ち向かうにはまだ早かったので 次の一歩を進めるために小さなテストをひねり出した
- 恥知らずにも既存のテストをコピペして テストを作成した
- さらに恥知らずにも 既存のモデルコードをまるごとコピペして テストを通した
- この重複を排除するまでは 家に帰らないと心に決めた


### Chapter06: テスト不足に気づいたら
十分な量のテストが無い場合 テストによって守られていないリファクタリングを行わざるを得ない  
そういう場合は あればよかったと思うテストを書こう  
書かなければ コードはリファクタリングの仮定でいつか壊れてしまう  
2つの Equals メソッドの中身を全く同じものにすれば プログラム上の意味を変えずに Franc の Equals メソッドを削除できる  

#### ふりかえり
- Dollar クラスから親クラス Money へ段階的にメソッドを移動した
- 2つ目のクラス(Franc)も同様にサブクラス化した
- 2つ目の Equals メソッドの際をなくしてから サブクラスの実装を削除した

#### 実際に開発してみた感想
Golang は継承が言語仕様にないから 埋め込みを利用するが それがうまくいかなかった  
ただ テストが通る状態でコードを変更することは確かに安心感があった  

1. 空の構造体を作る -> テストが通るか確認
2. 変数名を変える -> テストが通るか確認
3. 引数の型を変える -> テストコードを修正 -> テストが通るか確認
4. メソッドを 親の構造体に移す -> テストが通るか確認

このように 少しづつ変更し 壊れていないか確かめながら 次を変更して 目標に近づけていくことができた  


### Chapter07: 疑念をテストに翻訳する
Dollar と Franc を比較したらどうなるだろうという疑問に駆られた  

#### ふりかえり
- 頭の中にある悩みをテストとして表現した
- 完璧ではないものの まずまずのやり方(getClass)でテストを通した
- さらなる設計は 本当に必要になるときまで先延ばしにすることにした

#### 実際に開発してみた感想
最初は書籍に合わせて 型名で比較しようとした `reflect.ValueOf(m).Type() == reflect.ValueOf(a).Type()`  
しかし 埋め込みをしていることもあり 単純に型名を取得して 比較することができなかった  
それにより Money 型に 通貨名を足して 対応した(Chapter が進むと 通貨コードになるが まだしない)  


### Chapter08: 実装を隠す
Dollar と Franc の内容が似ているため 戻り値の型やサブクラスへの参照箇所を減らし サブクラスを消せるようにする  
そのためには Factory Method パターン を使う  

#### ふりかえり
- 重複を除去できる状態に一歩近づけるために Dollar と Franc にある2つの Times メソッドのシグニチャを合わせた
- せめてメソッド宣言だけは 親クラスに移動した
- Factory Method パターンを導入して テストコードから2つのサブクラスの存在を隠した
- サブクラスを隠した結果 いくつかのテストが冗長なものになったことに気がついたが いまはそのままにしておいた

#### 実際に開発してみた感想
コードの最初から DDD を意識して 生成メソッド つまり Factory Method パターン を使ってしまっていた  
どうやら インタフェースの実装をするとき レシーバは ポインタではダメっぽい?  


### Chapter09: 歩幅の調整
コードを書いている途中で 気になることが生じた  
この修正をいま行うべきだろうか それとも待つべきだろうか  
教科書的な答えは「いま行っている作業を止めないために 修正はまつべき」  
ただ 割り込みを楽しむために行うのもよい  
ただし __割り込みにさらに割り込むことはしない__ というルールが大事  

1. 通貨コードを取得して 正しいかチェックするテストを書く(コンパイルが通らない)
2. Money 型に抽象メソッドとして 書いてコンパイルを通す
3. 抽象メソッドの実装を Dollar と Franc に書く
4. Dollar と Franc の型のコンストラクタに初期値を持っていって 抽象メソッドの実装は同じ形にする
5. 実装を Money 型に移植して抽象メソッドを消し Dollar と Franc の型の実装を消す

#### ふりかえり
- 大きめの設計変更にのめり込みそうになったので その前に手前にある小さな変更に着手した
- 際を呼び出し型(Factory Method 側)に移動することによって 2つのサブクラスのコンストラクタを近づけていった
- リファクタリングの途中で少し寄り道をして Times メソッドの中で Factory Method を使うように変更した
- Franc に行ったリファクタリングを Dollar にも同様に 今度は大きい歩幅で一気に適用した
- 完全に同じ内容になった2つのコンストラクタを親クラスに引き上げた

#### 実際に開発してみた感想
インタフェースのメソッドを package private にしてしまっていた  
struct のインスタンス生成に フィールド名を毎回書いていたら わかりやすくはあるが フィールド名を変えたときに 全部変えないといけないという面倒が発生した  
-> struct のインスタンス生成に フィールド名を書くのはやめよう  
書籍では まだ Times() は Dollar や Franc 型で行っているが Factory Method の戻り値を Money にしたから すでに Money 型に Times() を移植している  


### Chapter10: テストに聞いてみる
検討に時間を割く代わりに コードを変更してテストを実行し 結果をコンピュータに教えてもらえばいい  
テストがあれば 試したほうが早いかどうかを選択できる  

分かりやすいエラーメッセージにするには toString メソッドを実装する  

掟破りにも テストを書かずにコードを書いてしまった  
しかし 以下の例外的な理由から今回はコードだけ書いた  
- 画面への出力をすぐに見たかった  
- toString はデバッグ出力のためだけに利用されるので バグが混入してもリクスは少ない  
- 既にテストはレッドバーの状態だった レッドバーの状態で新たにテストを作成するのは避けたい  

テスト無しでコードを変更するわけにはいかない  
手堅い方法は レッドバーの原因になった変更を巻き戻し グリーンバーに復帰するというものだ  

#### ふりかえり
- サブクラスたちの times メソッド実装の差異をなくすために まずはメソッド呼び出しをインライン化し 次にベタ書きの値を変数に置き換えた  
- デバッグ用途のみに使うtoString メソッドを テストを書かずに実装した  
- Franc の代わりに Money を返す変更を試み 動くか動かないかはテストに聞いてみた  
- 実験的な変更を巻き戻し もう1つテストを書いた 再度テストを通るように実装することで 今度は実験を成功に導いた  

#### 実際に開発してみた感想
10章でやることをほとんどすでに実装してしまっていた  
実装してしまっていたから 実感はないが Java でいう toString を go では String メソッドによって ポインタが任意のフォーマットで出力する方法を学んだ  


### Chapter11: 不要になったら消す
Dollar と Franc 型を消したから 何倍を表す Times メソッドも Dollar のときと Franc のときで区別する必要がなくなったから消す  

#### ふりかえり
- サブクラスの仕事を減らし続け とうとう消すところまでたどり着いた  
- サブクラス削除前の構造では意味があるものの 削除後は冗長になってしまうテストたちを消した  

#### 実際に開発してみた感想
dollar.go, franc.go のファイルを消したが __消してもテストが成功するという安心感__ が重要だと思った  


### Chapter12: 設計とメタファー
問題を難しくしているのは 複数の通貨を扱っていることをほとんど意識させないコードにしたいという設計上の制約  
ひとつの戦略として すべてのお金をすぐに「基準通貨」に変換変換してしまうことだが このやり方では為替レートの変更をうまく扱うことができない  
あるオブジェクトが望むように振る舞えないのならば 同じ外部プロトコル(メソッド群)を備える新たなオブジェクト(Imposter パターン)を実装し 仕事をさせればよい  
設計をひらめく瞬間に法則性はない  
自信を与えてくれるテストときちんと手入れされたコードは ひらめきへの備えであり いざひらめいたときに それを具現化するための備えでもある  
これから作るのは Money のように振る舞うが 2つの Money の合計を表現するようなオブジェクト  
最初のメタファーは 合計とは「財布」のようなものであるという考え方  
「式(Expression)」というメタファーも思いついた  

設計を考えるときの方向性  
-  中核を成すオブジェクトが それ以外の事柄をできるだけ知らないような設計を続けることで 柔軟性が高く かつ テスト, 再利用, 理解 が簡単な状態を保てるから
- 操作が増えていくことが予想できるなら 際限なく大きくなるのを防ぐため

コンパイラを通すために クラスにしてもよいが __インタフェースのほうが考えることが少なくて済む__  

#### ふりかえり
- 大きいテスト($5 + 10 CHF)を分割して 進み具合がわかる小さいテスト($5+$5)を作成した  
- これから行う計算のためにメタファーについて深く考えた  
- 前章で書いたテストを 新しいメタファーを使って書き直した  
- テストがコンパイルができるところまで早足で進んだ  
- テストを通した  
- 本当の実装を導くためのリファクタリングを楽しみにしつつ 少し不安も感じている  

#### 実際に開発してみた感想
コンパイラを通すために クラスではなく インタフェースの方が考えること少ないからって定義するのは 賢いと思った  


### Chapter13: 実装を導くテスト
コードの悪臭  
- キャストを行っている 本当はどんな Expression であれ動作しなければならない  
- Sum のフィールドにアクセスしている しかもそのフィールドのフィールドにさらにアクセスしている  

ほぼすべての場合において __クラスの明示的なチェックは ポリモフィズムに置き換えるべき__ だ  

著者は  
Bank 型 に定義してある `Reduce(source Expression, to string)` と  
Expression 型 に定義してある `Reduce(string)` が  
同じ名前なのに引数が違うことなど気にしている  

#### ふりかえり
- 重複を除去できていないので TODO リストの項目を「済」にしなかった  
- 実装の着想を得るためにさらに先に進むことにした  
- 後に必要になりそうなオブジェクト(sum)の作成を促すテストを書いた  
- 速やかに実装を行った(sum のコンストラクタ)  
- キャストを使って1か所で実装した後で テストが通るままで本来あるべき場所にコードを移した  
- ポリモフィズムを使って明示的なクラスチェックに置き換えた  

#### 実際に開発してみた感想
Sum 型 と同じメソッドを Money 型 にも定義して そのメソッドを インタフェースに引き上げるという手法は上手(__特に引き上げるという表現と抽象化の相性が良い__)  
`bank.Reduce()` の第一引数が Sum 型 だろうと Money 型 だろうと `bank.Reduce()` には同じように引数に入れられるのは美しい  
それは `bank.Reduce()` の第一引数がインタフェースであり Sum 型 も Money 型 も そのインタフェースを実装しているからであろう  
Sum 型 なら Sum 型 の中で定義された足し算の処理が行われるし Money 型 ならそのまま Money 型 が返るという仕組み  


### Chapter14: 学習用テストと回帰テスト
とりあえず コンパイルを通すために 中身の無いメソッドを定義して とりあえず グリーンにするために Money 型 で CHF なら 2で割るという処理を書いた  
そこから rate は bank が知っているべきという発想になり Money 型 で作っていた rate を bank から渡してもらおうと Money の Reduce() に関係するメソッドの引数に  
とりあえず bank を増やす戦略を一度している  

為替レートを表敬式で Bank の中に保存し検索できるようにしたい  
ハッシュテーブルを使えば 2つの通貨の組をレートに紐付けできる  
通貨が2つ入った配列を ハッシュテーブルのキーに使えるか?  
配列の equals メソッドは配列の中の要素まで等価比較を行うか?  
チーム外の誰かが書いたソフトウェアやメソッドに対して __メソッドを使い始める前に期待通りに動作するかテストを書いて確かめる__  
これを学習用テストという  

グリーンでいたはずなのに 想定外のレッドになったら 回帰テスト を書く  

#### ふりかえり
- 必要になると予想されていたパラメータ追加をすぐに行った  
- コードとテストの間のデータ重複をくくり出した  
- Java の言語仕様を調べるためのテスト(testArrayEquals)を書いた  
- 実装内部で使うためだけのヘルパークラスを個別のテスト無しで作成した  
- リファクタリング中にミスを犯したが 問題を再現するテストを追加して 着実に前進した  

#### 実際に開発してみた感想
最初は もし CHF と USD なら 2で割るという汚いコードでグリーンにするのが気持ち悪すぎた  
それに そんな余計なコードを足して 後で消すことが分かっているのに 修正するのが大変になる気がして嫌だった  
でもそれは __僕の頭が賢いと過信しすぎている__ ような気がした  
学習用テストの 依存しているパッケージの新しいバージョンがリリースされたときに使えるのは凄いと思った  


### Chapter15: テスト任せとコンパイラ任せ
多くの事柄を先送りにしたおかげで 1か所修正すると 2, 3か所と連鎖的に修正箇所が増える  
方針は2つある  
1つ目は 抽象度を落とし 具体的なテストを書いて まずは動作させて そこから着実に一般化する  
2つ目は コンパイラを信頼し 自分がミスしたら必ず教えてくれると信じて突き進む  

連鎖的な修正を避けるために 依存の終端から修正を始め 変更ごとにテストを動かし グリーンか確かめならが進む  

#### ふりかえり
- こうなったら良いというテストを書き 次にまず一歩で動かせるところまでそのテストを少し後退させた  
- 一般化(より抽象度の高い型で宣言する)作業を 末端から開始して頂点(テストケース)まで到達させた  
- 変更の際にコンパイラに従い(fiveBucks 変数の Expression 型への変更) 変更の連鎖を1つずつ仕留めた(Expression インターフェースへの Plus メソッドの追加等)  

#### 実際に開発してみた感想
変更して コンパイラに助けられて インタフェースを実装するか否か考えて 変更ごとにテストを動かし グリーンか確かめならが進む安心感はありがたい  


### Chapter16: 将来の読み手を考えたテスト
テストを書くのは プログラミングを楽しくやりがいのあるものにするためだけでなく 今考えていることを将来の仲間に伝えるロゼッタストーンの役割も担って欲しいから  
テストを書くときは読者のことを考えるのが 何よりも大切  

TDD をやっていると テストコードとプロダクトコードの行数は同じくらいになる  
つまり これまでの2倍コードを書けるようになるか 半分のコード量で同じだけの機能を書けるようになるか しないと __TDD のメリットを得られない__  

#### ふりかえり
- 将来読む人のことを考えながらテストを書いた  
- これまえのプログラミングスタイルと TDD との比較を自分自身で行うことが大事だと伝えた  
- 再び連鎖的に波及する定義変更を行い コンパイラに導かれながら修正を行った  
- 最後に簡単な実験を行い うまく機能しないとわかったので破棄して引き返した  

#### 実際に開発してみた感想
Times の戻り値を Expression にしたから Accessor インタフェースを実装していないことになってしまった  
Expression の実体は Money だから存在はするが...  
方法は2つ  
1. Expression を型アサーションして Money にする  
2. Expression に Accessor インタフェースも加える  
もし 2つ目を選択したら Sum 型 にも Amount() int, Currency() string の実装が必要になるが  
Sum 型 は Money が2つあるから どっちの amount か分からないし 合算後の amount にしようとしても  
Amount() の引数に Bank が渡せないし 難しそう  
よって 型アサーションを選択する  
クラスの明示的なチェックは ポリモフィズムに置き換えるべきだ という筆者の声が耳が痛い  
本当は `Expression interface` に `Equals()` を定義して 調整して `Equals()` の引数は Money か Sum か気にしなくていいように作るべきだろうな  


### Chapter17: 多国通貨の全体ふりかえり
#### ここから先はどうなるか
ツールは何かを忘れたり 見逃したりということがない  
ここから先はどうなるか という問いには テストは足りているか というものもある  
こう動いてはならない テストを書いてみる  
TODO リストが空のときは 設計を見直す良いタイミング  
設計の言葉と概念に齟齬はないだろうか, 現在の設計では除去が難しい重複はないだろうか  
長く残っている重複は 新たな設計の必要性を示唆  

#### メタファー: 設計の構造に与える劇的な効果について
式のメタファーにはパフォーマンスの懸念もあるが 実際の使われ方を見てから最適化を考えるので十分だと思う  

#### JUnit の使用状況: いつ どのように使っていたか
JUnit の実行ログ(何回実行したか, 何分間隔か)

#### コードメトリクス: 出来上がったコードをさまざまな角度から計測してみる
クラス数, メソッド数, 行数, 循環的複雑度, 行数/メソッド の割合

#### プロセス: レッド・グリーン・リファクタリング をそれぞれどれくらい作業しているか
テストを書くことを1つのステップだとして  
それをコンパイルして  
テストを走らせ  
さらにリファクタリングするまでの1週に  
どのくらいの変更が必要になるだろうか  

#### テスト品質: TDD のテストは従来の指標から見てどうなのか
TDD は以下のテストの代替になるとは考えない
- パフォーマンステスト
- 負荷テスト
- ユーザビリティテスト

#### ふりかえり
- テストをきれいに機能させる3つのアプローチ 仮実装, 三角測量, 明白な実装  
- テストとコードの間の重複除去が 設計を駆動する  
- テストの間のギャップを制御する能力 路面が滑りやすいならグリップを増し 路面が良いならより速く


### その他
TDD のゴールは __動作するきれいなコード__  

#### テスト駆動開発のルール
1. 自動化されたテストが失敗したときのみ 新しいコードを書く
2. 重複を除去する

#### 作業順序
1. レッド  
動作しない、 おそらく最初のうちはコンパイルも通らないテストを1つ書く  
2. グリーン  
そのテストを迅速に動作させる。 このステップでは罪を犯してもよい。  
3. リファクタリング  
テストを通すために発生した重複をすべて除去する  

#### TDD のリズム
1. まずはテストを1つ書く
2. すべてのテストを走らせ 新しいテストの失敗を確認する
3. 小さな変更を行う
4. すべてのテストを走らせ すべて成功することを確認する
5. リファクタリングを行って重複を除去する

#### 依存性と重複
テストコードとプロダクトコードの間にある重複が問題なのではない  
重複は ほとんどの場合コードの複数の場所に同じ表現が出てくるような ロジックの重複の形で発見される  
オブジェクトを使えば抽象化によってロジックの重複をきれいに取り除ける  
プログラムの重複を取り除くと 依存性も取り除かれる  

#### 学習用テスト
チーム外の誰かが書いたソフトウェアのテストを書くのはどのようなときか  
そのソフトウェアの新機能を初めて使う際に書いてみよう  
単にそのメソッドを使おうとする代わりに API が期待通りに動作するかテストを書いて確かめる  
もし API が想定通りに動くなら 初回からテストは通るだろう  
依存しているパッケージの新しいバージョンがリリースされたら まず学習用テストが走る  
もし学習用テストが失敗したら 自分たちのコードのテストも動きっこない  
学習用テストが通るようになったら 自分たちのコードのテストももちろん通る  

#### 回帰テスト
不具合が報告されたら 不具合を再現させる最小のテストケースを書き 失敗を見届ける  
そのテストが通るようになったら 不具合が修正されたということになる  
回帰テスト を 書くときは 書くべきことにどうやったら気づけたかを考える  
もし 不具合部分を独立してテストするために リファクタリングが必要になれば システムから "まだ設計を終えていない" というメッセージと心がける  

#### フィクスチャー
複数のテストから使われる共通のオブジェクトを作るには  
テストメソッド内のローカル変数をインスタンス変数に引き上げ オーバーライドした setUp メソッドの中で初期化を行う  
プロダクトコードの重複を取り除くなら テストコードの重複も取り除きたくなるもの  
オブジェクトを作成してテストの事前状態を作り上げるためのコードのほうが オブジェクトを操作して検証を行うコードより 長くなりがち  

重複は以下の理由で悪である  
- 書くのに時間がかかる コピペであってもかかる テストコードはもっと速く書きたい  
- インタフェースを手で変更するときに 複数箇所を変更しなければならない  

重複の良い面  
- テストの準備がアサーションと同じ場所に書かれているため 上から下へ読みやすい  

どちらのスタイルがよいか 試すと良い  
筆者は 共通コードを抽出する道を選ぶ(細部まで覚える記憶力を備えている)が テストの読み手は 覚えることが多すぎると不平を漏らすらしい  

#### 因果ループ図
因果ループ図の主な目的は 系の要素同士がどう影響を与え合うかを解き明かすこと  
##### 因果ループ図の要素
- アクティビティ  
  単語あるいは短いフレーズ(要素, ノードな感じ)  
- 正の接続  
  正の相関 片方が増加すれば もう片方は増加する 矢印で表現  
- 負の接続  
  負の相関 片方が増加すれば もう片方は減少する 矢印(白丸付き)で表現  

##### フィードバック  
アクティビティの効果は巡り巡って自分のところに戻ってくることが多い  
- 正のフィードバック  
  系に属するアクティビティを促進する効果 負の接続が偶数(2n)個のとき  
- 負のフィードバック  
  系に属するアクティビティを減退する効果 負の接続が奇数(2n+1)個のとき  

良いアクティビティを促進するような善い円環を作る  
非生産性, 破壊的アクティビティを促進するような死のスパイスは避ける  
良いアクティビティのやりすぎを避けるために 負のフィードバックサイクルを作る  

##### 系の制御
うまくいってない系があるとき
- 正のフィードバックグループの向きを返る  
  テストと自信の間に正のフィードバックがあり テストの失敗が自信の喪失 になっているなら テストを成功して自信の回復 をする  
- アクティビティが促進されすぎないように 負のフィードバックループを入れて制御(もしかして 接続の強度って概念入れたら面白い?w)  
- 接続を加えたり切り離したりして 無用なループを取り除く  

#### xUnit の全体ふりかえり
自分自身で xUnit を実装してみる意義
- 熟達  
  xUnit の精神はシンプルさにある  
  自分自信で実装することによって 自分が一番よく知っている道具が手に入る  
- 探索  
  新しいプログラミング言語に触るときには まず xUnit を実装してみる  
  8から10個のテストが動作するようになるころには 日々のプログラミングに必要な機能は登場していることだろう  

#### TODO リスト
コードを書く際にストレスに悩まされないコツは どこに行くべきかがわかるまで 一歩も踏み出さないこと  
今週や今月行うこと のような粗い粒度ではなく __頭の中をすべて書き出す__  
それらを"すぐやる", "あとで"のリストに加えるか "やる必要なし"であるかを __素早く意識的に判断__ すればよいだけ  
脱線はひとまず TODO リスト に加える(たぶん 時間軸も必要だろうけど 分類先を増やすとそれはそれで分類させる労力がかかるんだろうなぁ)

#### やり直す
手詰まりで途方に暮れてしまったときはどうするべきか  
コードを捨てて やり直そう  

#### テスティングのパターン
- Mock Object(偽装オブジェクト)パターン
- Self Shunt(自己接続)パターン
- Log String(記録用文字列)パターン
- Crash Test Dummy(衝突実験ダミー人形)パターン

#### 失敗させたままのテスト
独りでプログラミングしているときは 最後に書いていたテストを失敗する状態にして終えよう  
コーディングに戻ってきたときに どこから始めるべきか明白  
失敗させたままにしてあるコードは退化させているのではなく プログラムの現状を明らかにしている  

#### 1から多へ
オブジェクトのコレクションを扱う操作を実装するとき  
単数のときの操作を実装し それからコレクションでも動くようにする  

#### 例外のテスト
例外発生を期待するテストは 期待される例外だけをキャッチして握りつぶすように書いて その例外が発生しなかったときは テストが失敗するように書く  

#### 良いテストを見分けることができるか
設計に問題を抱えている場合 テストに以下のような兆候が現れる  
- 前準備に要するコードが長い  
  -> アサーションを行うテスト対象オブジェクトを分割しよう  
- 前準備コードの重複  
  -> 共通の前準備コードを配置する適切な場所がすぐに見つからないのは 互いに密に関連しあうオブジェクトが多い  
- テスト実行時間が長い  
  -> 長いとテストを行わなくなる, 部分的なテストが難しいのは設計の問題  
- 脆いテスト  
  -> 思わぬタイミングで失敗するテストは 意外な形で他の部分に影響している可能性がある 副作用がある可能性があるってことかな  

#### どのようなときにテストを消すべきか
2つのテストの間に重複が発生した場合 2つの判断基準がある  
- 自信: テストを消すことでシステムの振る舞いに対する自信が減るならば 消してはならない  
- コミュニケーション: テストの読み手には異なるシナリオと映るならば 消さない方がよい  

#### 途中から TDD に乗り換えるにはどうすればよいか
テストのことを考えずに書かれたコードは えてしてテストが書きにくい  
インタフェースが設計されていないので ロジックを一部切り出して動かし 結果を確かめるくらいしかできない  
__金を生まずに消費するだけでは 持続性のあるプロセスとは言えない__  
変更のスコープを狭める  

#### TDD は誰のためのものか
すべてのプログラミングプラクティスには 価値体系が織り込まれている  
TDD は"より良いコードを書けば よりうまくいく" という素朴で奇妙な仮設によって成り立っている  
TDD を行うと 正しいタイミングで正しい問いに気づけるようになり よりきれいな設計になり 学びを得るに従って さらに設計を改善できる  

#### TDD とパターンの関係
__反復可能な振る舞いを 規則にまで還元__ することで 規則の適用は機械的に反復可能になる  
毎回すべて最初から議論し直すより 速い  
最初は 規則を調べたり 新たな規則を書くために立ち止まったりした  
慎重に完璧に考え抜いた設計は正しくなかった  
単にシステムにそのときどうしてほしいかを考え 後は設計が自ら整理さえる方に任せたほうが良い結果になった  

#### 訳者解説
手を動かす(写経をしよう) -> TDD の本質は 精神状態のコントロール, 不安と自信の制御にある  
TDD はスキル -> だから修練で身につく 量は質に転化する TDD は個人のスキルだから 言語や環境に左右されない  
テストは質を上げない -> テストは質がわかるだけ 質を上げるのはプログラミング テストを書いても設計を改善しないなら ただの回帰テストでしかない  
だからテストを書きながらカイアhつすることで 設計が良い方向に革 コードが改善され続け それによって開発に前向きになることが TDD のゴール  
優れたプログラミングテクニックやパラダイムは"使いすぎてみて"少し戻ってくるくらいが良い塩梅  
テストファースト, デザインパターン, リファクタリング, TDD, モックオブジェクト, GOOS スタイル, BDD, DDD, 関数プログラミング など 
すべてに手を出してみて 夢中になり 正気に戻り 良いと思ったエッセンスを自分の中に残してください  

### chapter30:リファクタリング
#### 差異をなくす
よく似ているコードを共通化するには コードの内容をだんだん近づけていって 完全に一致したところでひとつにしよう  

#### 変更の分離
変更するげき部分を分離独立させよう  
変更箇所を分離独立させた後に実際の変更を行えば 変更範囲が絞られるため 変更を元に戻せるようにもなる  
ただし これらの作業を盲目的に行ってはならない  
メソッドを追加するコスト, コード上に新たな概念が示されていることの価値を __天秤に__ かけなければならない  

#### データ構造の変更
データの持ち方を変えるには データを一時的に複製しよう  

方法1: 内側から外側(内部構造を書き換えた後に 外部インタフェースを変更)  
1. 新構造のためのインスタンス変数を定義  
2. 旧構造でデータが設定されている部分をその変数に置き換える  
3. 旧構造のデータを使っている部分をその変数に置き換える  
4. 旧構造のコードを消す  
5. 外部インタフェースに新構造を反映する  

方法2: 外部から内部(API 側から変更を行いたい)  
1. 新構造のパラメータを追加する  
2. 新構造のパラメータを内部で旧構造に変換する  
3. 旧構造のパラメータを削除する  
4. 旧構造を使っている部分を新構造に置き換えていく  
5. 旧構造のコードを削除する  

#### メソッドの抽出
1. メソッドの中から 新しいメソッドとして切り出す意味のある部分を探す  
  ループの中身, ループ全体, 条件分岐の各分岐などがよくある抽出対象  
2. 抽出する範囲の外で 一時変数への代入が行われていないことを確認する  
3. 旧メソッドから該当範囲のコードをコピーしコンパイルする  
4. 旧メソッドの一時変数やパラメータの中で新メソッドから使うものを 新メソッドのパラメータに追加する  
5. 旧メソッドの中から新メソッドを呼び出す  

#### メソッドのインライン化
ねじれたり散らかったりしてしまった制御フローをシンプルにするには メソッド呼び出し部分をメソッドそのもので置き換える  
1. 対象のメソッドをコピーする  
2. メソッド呼び出し部に そのメソッド本文をペーストする  
3. 仮引数を実引数に置き換える  

いくつかの抽象化層をインライン化し 何が実際に行われているかを確認した後に 想像ではなく 実際の状況に合わせて再度抽象化を行う  

#### インタフェースの抽出
1. インタフェースを宣言する  
  ときには既存クラス名を使いたいこともある そのようなときは 先にクラス名の改名を行う  
2. そのインタフェースを既存クラスが実装するようにする  
3. 必要なメソッドをインタフェースに加え クラスの方では必要に応じて メソッドの可視性を上げる  
4. コードの中で宣言される型を可能な限りクラスからインタフェースに書き換える  

#### メソッドの移動
他のオブジェクトに対して1つ以上のメッセージ送信(メソッド呼び出し)を行っているところを見つけると 疑問が首をもたげてくる  
例えば 面積を求める処理をする部分で `面積 = (図形.上() - 図形.下()) * (図形.右() - 図形.左())` なんてあったら  
4回も図形インスタンスから値を取り出すのではなく `面積 = 図形.面積()` と図形クラスに直接面積を聞くメソッドに移動させる  

#### メソッドオブジェクト
1. オブジェクトを作り メソッドと同じパラメータを保持させる  
2. ローカル変数は そのオブジェクトのインスタンス変数として表現する  
3. 単一メソッドを定義し その中身は元のメソッドと同一にする  
4. 元のメソッドの中でオブジェクトをインスタンス化し 単一メソッドを呼び出す  

複数のパラメータやローカル変数を必要とする込み入ったメソッドを表現するには メソッドをオブジェクトとしてくくり出す  
既存システムに 新たなロジックを足す準備段階で有用  

#### パラメータの追加
多くの場合 パラメータの追加は機能拡張の1ステップ  

#### メソッドからコンストラクタへのパラメータ移動
あるオブジェクトの複数のメソッドに対して 同じパラメータを渡している場合は あらかじめパラメータを一度だけ渡しておくことで重複を排除し API をシンプルにできる  

### chapter30: デザインパターン
なにかの書籍で デザインパターンは ただパターンを書き出しただけで すべてがベストプラクティスというわけではないと聞いたな  

- Command: 処理の実行をただのメッセージではなくオブジェクトで表現  
- Value Object: 一度作られたら絶対に値が変わらないオブジェクトを作り 別名参照問題を防ぐ  
- Null Object: 特殊な状況をオブジェクトで表現  
- Template Method: 処理の順序を抽象メソッドの並びで表現し 個別の処理は継承によって表現  
- Pluggable Object: 2種類以上の実装を持つオブジェクトを呼び出すことでバリエーションを表現  
- Pluggable Selector: インスタンスごとに異なるメソッドを動的に呼び出すことで 余計なサブクラスを作らずに済む  
- Factory Method: コンストラクタではなくメソッドを呼び出してオブジェクトを作成する  
- Imposter: 既存のプロトコルの新たな実装を作成して バリエーションを生み出す  
- Composite: オブジェクトたちの振る舞いの組み合わせを1つのオブジェクトとして表現  
- Collecting Parameter: さまざまなオブジェクトから処理結果を集めるためのオブジェクトを引数に渡していく  


| パターン | テスト | リファクタリング |
| :-: | :-: | :-: |
| Command | ○ |   |
| Value Object | ○ |   |
| Null Object |   | ○ |
| Template Method |   | ○ |
| Pluggable Object |   | ○ |
| Pluggable Selector |   | ○ |
| Factory Method | ○ | ○ |
| Imposter | ○ | ○ |
| Composite | ○ | ○ |
| Collecting Parameter | ○ | ○ |

#### Value Object パターン
回避する方法
1. 依存しているオブジェクトを渡さない  
渡すときはコピーを渡す  
ただし 時間もメモリも消費するし 状態の共有ができなくなる  
2. Observer パターン  
オブジェクトへの依存を明示的に登録し 状態が変更されたら通知がくるようにする  
ただし 処理フローが追いにくく 依存の登録や解除ロジックは汚くなりがち  
3. Value Object パターン  
Value Object には コンストラクタで設定したインスタンス変数の値が変わってはならないという成約  
オブジェクトが Value Object であるためには 操作はすべて新しいオブジェクトを返さなければならない  
ただし パフォーマンスに問題が出る可能性はあるが 
パフォーマンス分析をするには実際のデータで リアルな利用パターンを試し プロファイリングを行ってからでないと 
__パフォーマンスを問題にする資格はない__  
Value Object を作る際は 等価性比較を実装しなければならない(かつ 多くのプログラミング言語においては ハッシュ化も実装しなければならない)  
インスタンスが異なっていることと オブジェクトが意味的に同じことなのは 関係がないから  

#### Factory Method パターン
オブジェクトの作成に柔軟性を持たせたいとき コンストラクタで作るのではなく メソッドを使ってオブジェクトを作成する  
直接インスタンスを作るのではなく 間接的な役割をするメソッドを使うことで 異なるクラスのインスタンスを返せるようになる  
オブジェクトを作成するメソッドのことを Factory Method という  
Factory Method の短所は オブジェクトを作成するメソッドであることを覚えておく必要があること  
柔軟性が不要なら コンストラクタの方が良い  
気づき: 松岡さんの 『ドメイン駆動設計 サンプルコード & FAQ』 では コンストラクタをプライベートにして 気づくきっかけにするアイデアを提示していたなぁ  

#### Imposter(なりすまし) パターン
処理に新しいバリエーションを導入するには 既存オブジェクトと同じプロトコルを備え 実装は異なる新しいオブジェクトを作る  
手続き型で書かれたコードにバリエーションをもたらすには 条件分岐を導入する  
条件分岐は増殖するため ポリモフィズムを導入することで重複したコードを健全な状態に戻せる  
新しいバリエーションを導入すると 複数のメソッドを変更しなければならなくなる  
TDD では このような設計判断は テストを書いていて 新しいシナリオを表現しなければならないが 既存のオブジェクトではシナリオが表現できない ときに現れる  

Money の集合を Money のように振る舞わせることにたどり着くにも洞察力が必要  
リファクタリングの過程でよく現れる Imposter  
1. Null Object: データの不在をデータの存在と同じように扱えるようにする
2. Composite: オブジェクトの集合を単体のオブジェクトと同様に扱えるようにする
