- encryption : [名] 暗号化(暗号にすること)
- cryptography : [名] (学問としての)暗号法、暗号学
- cipher : [名] 暗号化アルゴリズム(サイファーと読む)

Go 言語で標準の暗号化パッケージがある
crypto

一人でしか使わないから共通鍵暗号方式でいいや
共通鍵暗号方式
- ブロック暗号化方式(128, 256 bit など、ある程度まとまった単位のデータに対して暗号化) 例: DES, AES
- ストリーム暗号化方式(乱数を利用し、データを1 bit や1 byte など細かい単位で暗号化) 例: RC4
ストリーム暗号化よりブロック暗号化の方が研究されて安全性が高い

ブロック暗号の中でも
- ECB モード(各ブロックに対して同じ処理を繰り返す)
同じ平文ブロックは同じ暗号文ブロックになるし 攻撃者が暗号化ブロックを入れ替えたら平文も入れ替わるなど問題があるため実用的でない
- CBC モード(前のブロックの結果に応じて処理が変わる)
1つ前の暗号ブロックと平文ブロックのXORをとってから暗号化を行う
SSL/TLS にも利用されている
ただ 暗号化ブロックの一部に欠損すると平文にすべてに影響が出る

ストリーム暗号の中でも
- CFB モード
1つ前の暗号ブロックを暗号化したもの(Key Stream)と平文ブロックのXOR
- OFB モード
1つ前の暗号化の出力(Key Stream)を次の暗号化の入力とする
暗号化の出力(Key Stream)と平文でXORをとる(Key Streamを事前につくっておくことができる)
もし暗号結果が同じものになったらそれ以後 Key Stream は全て同じ値になってしまう
暗号文を1ビット反転させると平文も1ビット反転する
- CTR モード
1つずつ増加していくカウンタを暗号化して Key Stream を作り出す
カウンタを暗号化して Key Stream とする
カウンタは暗号化のたびに異なる値(ノンス)をもとにしてつくる
暗号文を1ビット反転させると平文も1ビット反転する
暗号結果が同じになってもそれ以後の Key Stream が同じ値になることがない
- GCM モード
CTR が暗号文を作り出すと同時に "この暗号文は正しい暗号化によって作られたものである" という認証子を作り出すため 暗号文の偽装を見抜くことができる
TLS1.2で使われる
IV が必要ない
AEAD の一種である

CFB, OFB, CTR はブロック暗号を使って ストリーム暗号を作り出しているとみなすことができる

| モード | ランダム位置からの暗号化 | ランダム位置からの復号 | パディング要否 |
|:-:|:-:|:-:|:-:|
| ECB | 可能 | 可能 | 必要 |
| CBC | 不可 | 可能 | 必要 |
| CFB | 不可 | 可能 | 不要 |
| OFB | 不可 | 不可 | 不要 |
| CTR | 可能 | 可能 | 不要 |
ランダムな位置からの暗号化や復号ができると並列処理が得意

アメリカ国立標準技術研究所(NIST) は 昔 DES を使ってたけど ちょっと前から AES にしたらしい
僕も AES で遊ぼーっと

AESの鍵長さは
16 byte(AES-128 という)
24 byte(AES-192 という)
32 byte(AES-256 という)

NewCipher は cipher.Block インタフェースを返す
example01() は ただのブロック暗号で 16バイトの平文しか暗号化できない
```go
	// example01() でどっちも16になるけど aes.BlockSize が16になる意味が分からない
	fmt.Println(len(plainText))
	fmt.Println(aes.BlockSize)
```

example02() は 16バイトの倍数の平文を暗号化できる
初期化ベクトルに応じて暗号文が変わる

example03() は CTR つまり  パディングが要らず任意の長さの平文 や ランダムな位置からの暗号化や復号 ができる

AES を使った上でストリーム暗号としている?

[総当たり攻撃時のパスワード最大解読時間の表(by 上野宣)について分析した](https://qiita.com/ockeghem/items/5a5e73528eb0ee055428)
>現在の技術水準ではMD5によるハッシュ保存は否定されており、bcryptなど安全なパスワード保存方法が推奨されます。
