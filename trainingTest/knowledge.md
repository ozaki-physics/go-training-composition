# テスト駆動開発の練習
- 一気にテストする  
`go test ./trainingTest/...`  
- 任意のチャプターだけテストする  
`go test ./trainingTest/chapter01/...`  
- 任意のチャプターの任意のディレクトリだけテストする  
`go test ./trainingTest/chapter01/money/`  

## 参考文献 References
テスト駆動開発  
著者: Kent Beck  
訳者: 和田 卓人  
出版社: 株式会社オーム社  
2020/09/10: 第1版 第7刷  
2017/10/20: 第1版 第1刷  

[テスト駆動開発(本)を Go 言語で取り組んでみる](https://qiita.com/eyuta/items/d18296d13aa68523f505)  
とても賢い方法で実装してあったりする  
1. 6章で 埋め込みを使いつつ Equals() の引数をインタフェースにする賢さ  
  埋め込みをすると型が変わっちゃうから扱いにくかったが インタフェースにすることで埋め込みにも対応した  
2. 7章で 書籍のように型を直接比較するのではなく 型のような意味を持った name を追加する賢さ  
  埋め込みやってるから単純に型を取得するだけでは 等しいことを表現できなかった  
3. 1つのファイルで差分を表現しつつ コミットログじゃない方法で各章のコードを残す方法に ブランチを使っている賢さ  
  僕は 各章でファイルとして分けたが 前の章との差分が分かりにくいし import の Chapter を変更忘れてハマることがあった  
  -> 各ブランチをマージすることで main ブランチは差分で各章を比較できるし ブランチ切り替えると 各章でのコードが見れる  
4. 8章で Equals() のレシーバ側の値の取り出し方が インタフェースの実装メソッドではなく 直接フィールドにアクセスしている賢さ  
  -> 引数との差別化ができて良い  

### 目次 Table of contents
- Chapter01: 仮実装
- Chapter02: 明白な実装
- Chapter03: 三角測量
- Chapter04: 意図を語るテスト
- Chapter05: 原則をあえて破るとき
- Chapter06: テスト不足に気づいたら
- Chapter07: 疑念をテストに翻訳する
- Chapter08: 実装を隠す
- Chapter09: 歩幅の調整
- Chapter10: テストに聞いてみる
- Chapter11: 不要になったら消す
- Chapter12: 設計とメタファー
- Chapter13: 実装を導くテスト
- Chapter14: 学習用テストと回帰テスト
- Chapter15: テスト任せとコンパイラ任せ
- Chapter16: 将来の読み手を考えたテスト
- Chapter17: 多国通貨の全体ふりかえり

### Chapter01: 仮実装
最初に __TODO リスト__ を作る  
テストを書く  
気づいたことは TODO リストに加えていく  
最初はコンパイラを通す  
次に レッド を確認する  
TDD で大事なのは 細かいステップを踏み続けられること  

#### ふりかえり
- 書くべきテストのリストを作った
- どうなったら嬉しいかを小さいテストコードで表現した
- 空実装を使ってコンパイラを通した
- 大罪を犯しながらテストを通した
- 動くコードをだんだんと共通化し ベタ書きの値を変数に置き換えていった
- TODO リストに項目を追加するに留め 一度に多くのものを相手することを避けた


### Chapter02: 明白な実装
仮実装: コードでまずベタ書きの値を使い 実装を進めるに従って 徐々に変数に置き換えていく  
明白な実装: すぐに頭の中の実装をコードを落とす  

#### ふりかえり
- 設計の問題(今回は副作用)をテストコードに写し取り その問題点のせいでテストが失敗するのを確認した
- から実装でさっさとコンパイルを通した
- 正しいと思える実装をすぐに行い テストを通した


### Chapter03: 三角測量
Value Object パターン を使うメリットは 別名参照問題を回避できること  
別名参照問題: 2つのオブジェクトが同じ参照先を見ていて 片方で値を変えると もう片方の値も変わってしまう問題  

三角測量を真似て コードを一般化できるのは 2つ以上の実例があるときだけだと考えてみよう  
ただし テストコードとプロダクトコード間の重複は無視する  
三角測量はどうリファクタリングしていいか分からないとき や 自分の設計のどこが可動域として考えているかはっきりさせたいときに使える  

#### ふりかえり
- Value Object パターンを満たす条件が分かった
- その条件を満たすテストを書いた
- シンプルな実装を行った(まずは true を返すだけ)
- すぐにリファクタリングを行うのではなく もう1つテストを書いた(三角測量)
- 2つのテストを同時に通すリファクタリングを行った


### Chapter04: 意図を語るテスト
構造体同士の比較(Equals メソッド)を定義したから  
直接 構造体の中身の値同士を比較してたテストから 構造体同士を比較するテストに変更した  
等価性比較が正確に実装されていることを検証できていないなら かけ算のテストも検証できていないというリスクを受け入れた  
もし リスクを取ってうまくいかなかったら教訓にする  
ただ グリーンなのでリスクを取って進むことができる  

#### ふりかえり
- 作成したばかりの機能を使って テストを改善した
- そもそも正しく検証できていないテストが2つあったら もはやお手上げだと気づいた
- そのようなリスクを受け入れて先に進んだ
- テスト対象のオブジェクトの新しい機能を使い テストコードとプロダクトコードの結合度を下げた(値を取得するメソッドを private にした)


### Chapter05: 原則をあえて破るとき
フェーズのリズムは  
1. テストを書く
2. コンパイラを通す
3. テストを走らせ 失敗を確認する
4. テストを通す
5. 重複を排除する

各フェーズには フェーズなりの目的と解決法がある  
最初の3個のフェーズはなるべく速く通過して 新しい機能がどの状態にあるか分かるところまで行きたい  
そのため どのような罪を犯してもよい(コピー&ペースト など)  
ただ コピー&ペースト による再利用は 抽象化の敗北であり きれいな設計を殺すことになるので すぐにこの大罪を贖うこと  
コピー&ペースト をしたため 現状 Dollar と Franc は同じ構造体の形をしている

#### ふりかえり
- 大きなテストに立ち向かうにはまだ早かったので 次の一歩を進めるために小さなテストをひねり出した
- 恥知らずにも既存のテストをコピペして テストを作成した
- さらに恥知らずにも 既存のモデルコードをまるごとコピペして テストを通した
- この重複を排除するまでは 家に帰らないと心に決めた


### Chapter06: テスト不足に気づいたら
十分な量のテストが無い場合 テストによって守られていないリファクタリングを行わざるを得ない  
そういう場合は あればよかったと思うテストを書こう  
書かなければ コードはリファクタリングの仮定でいつか壊れてしまう  
2つの Equals メソッドの中身を全く同じものにすれば プログラム上の意味を変えずに Franc の Equals メソッドを削除できる  

#### ふりかえり
- Dollar クラスから親クラス Money へ段階的にメソッドを移動した
- 2つ目のクラス(Franc)も同様にサブクラス化した
- 2つ目の Equals メソッドの際をなくしてから サブクラスの実装を削除した

#### 実際に開発してみた感想
Golang は継承が言語仕様にないから 埋め込みを利用するが それがうまくいかなかった  
ただ テストが通る状態でコードを変更することは確かに安心感があった  

1. 空の構造体を作る -> テストが通るか確認
2. 変数名を変える -> テストが通るか確認
3. 引数の型を変える -> テストコードを修正 -> テストが通るか確認
4. メソッドを 親の構造体に移す -> テストが通るか確認

このように 少しづつ変更し 壊れていないか確かめながら 次を変更して 目標に近づけていくことができた  


### Chapter07: 疑念をテストに翻訳する
Dollar と Franc を比較したらどうなるだろうという疑問に駆られた  

#### ふりかえり
- 頭の中にある悩みをテストとして表現した
- 完璧ではないものの まずまずのやり方(getClass)でテストを通した
- さらなる設計は 本当に必要になるときまで先延ばしにすることにした

#### 実際に開発してみた感想
最初は書籍に合わせて 型名で比較しようとした `reflect.ValueOf(m).Type() == reflect.ValueOf(a).Type()`  
しかし 埋め込みをしていることもあり 単純に型名を取得して 比較することができなかった  
それにより Money 型に 通貨名を足して 対応した(Chapter が進むと 通貨コードになるが まだしない)  


### Chapter08: 実装を隠す
Dollar と Franc の内容が似ているため 戻り値の型やサブクラスへの参照箇所を減らし サブクラスを消せるようにする  
そのためには Factory Method パターン を使う  

#### ふりかえり
- 重複を除去できる状態に一歩近づけるために Dollar と Franc にある2つの Times メソッドのシグニチャを合わせた
- せめてメソッド宣言だけは 親クラスに移動した
- Factory Method パターンを導入して テストコードから2つのサブクラスの存在を隠した
- サブクラスを隠した結果 いくつかのテストが冗長なものになったことに気がついたが いまはそのままにしておいた

#### 実際に開発してみた感想
コードの最初から DDD を意識して 生成メソッド つまり Factory Method パターン を使ってしまっていた  
どうやら インタフェースの実装をするとき レシーバは ポインタではダメっぽい?  


### Chapter09: 歩幅の調整
コードを書いている途中で 気になることが生じた  
この修正をいま行うべきだろうか それとも待つべきだろうか  
教科書的な答えは「いま行っている作業を止めないために 修正はまつべき」  
ただ 割り込みを楽しむために行うのもよい  
ただし __割り込みにさらに割り込むことはしない__ というルールが大事  

1. 通貨コードを取得して 正しいかチェックするテストを書く(コンパイルが通らない)
2. Money 型に抽象メソッドとして 書いてコンパイルを通す
3. 抽象メソッドの実装を Dollar と Franc に書く
4. Dollar と Franc の型のコンストラクタに初期値を持っていって 抽象メソッドの実装は同じ形にする
5. 実装を Money 型に移植して抽象メソッドを消し Dollar と Franc の型の実装を消す

#### ふりかえり
- 大きめの設計変更にのめり込みそうになったので その前に手前にある小さな変更に着手した
- 際を呼び出し型(Factory Method 側)に移動することによって 2つのサブクラスのコンストラクタを近づけていった
- リファクタリングの途中で少し寄り道をして Times メソッドの中で Factory Method を使うように変更した
- Franc に行ったリファクタリングを Dollar にも同様に 今度は大きい歩幅で一気に適用した
- 完全に同じ内容になった2つのコンストラクタを親クラスに引き上げた

#### 実際に開発してみた感想
インタフェースのメソッドを package private にしてしまっていた  
struct のインスタンス生成に フィールド名を毎回書いていたら わかりやすくはあるが フィールド名を変えたときに 全部変えないといけないという面倒が発生した  
-> struct のインスタンス生成に フィールド名を書くのはやめよう  
書籍では まだ Times() は Dollar や Franc 型で行っているが Factory Method の戻り値を Money にしたから すでに Money 型に Times() を移植している  


### Chapter10: テストに聞いてみる
#### ふりかえり


### Chapter11: 不要になったら消す
#### ふりかえり


### Chapter12: 設計とメタファー
#### ふりかえり


### Chapter13: 実装を導くテスト
#### ふりかえり


### Chapter14: 学習用テストと回帰テスト
#### ふりかえり


### Chapter15: テスト任せとコンパイラ任せ
#### ふりかえり


### Chapter16: 将来の読み手を考えたテスト
#### ふりかえり


### Chapter17: 多国通貨の全体ふりかえり
#### ふりかえり


### その他
TDD のゴールは __動作するきれいなコード__  

#### テスト駆動開発のルール
1. 自動化されたテストが失敗したときのみ 新しいコードを書く
2. 重複を除去する

#### 作業順序
1. レッド  
動作しない、 おそらく最初のうちはコンパイルも通らないテストを1つ書く  
2. グリーン  
そのテストを迅速に動作させる。 このステップでは罪を犯してもよい。  
3. リファクタリング  
テストを通すために発生した重複をすべて除去する  

#### TDD のリズム
1. まずはテストを1つ書く
2. すべてのテストを走らせ 新しいテストの失敗を確認する
3. 小さな変更を行う
4. すべてのテストを走らせ すべて成功することを確認する
5. リファクタリングを行って重複を除去する

#### 依存性と重複
テストコードとプロダクトコードの間にある重複が問題なのではない  
重複は ほとんどの場合コードの複数の場所に同じ表現が出てくるような ロジックの重複の形で発見される  
オブジェクトを使えば抽象化によってロジックの重複をきれいに取り除ける  
プログラムの重複を取り除くと 依存性も取り除かれる  

#### Value Object パターン
回避する方法
1. 依存しているオブジェクトを渡さない  
渡すときはコピーを渡す  
ただし 時間もメモリも消費するし 状態の共有ができなくなる  
2. Observer パターン  
オブジェクトへの依存を明示的に登録し 状態が変更されたら通知がくるようにする  
ただし 処理フローが追いにくく 依存の登録や解除ロジックは汚くなりがち  
3. Value Object パターン  
Value Object には コンストラクタで設定したインスタンス変数の値が変わってはならないという成約  
オブジェクトが Value Object であるためには 操作はすべて新しいオブジェクトを返さなければならない  
ただし パフォーマンスに問題が出る可能性はあるが 
パフォーマンス分析をするには実際のデータで リアルな利用パターンを試し プロファイリングを行ってからでないと 
__パフォーマンスを問題にする資格はない__  
Value Object を作る際は 等価性比較を実装しなければならない(かつ 多くのプログラミング言語においては ハッシュ化も実装しなければならない)  
インスタンスが異なっていることと オブジェクトが意味的に同じことなのは 関係がないから  

#### 差異をなくす
よく似ているコードを共通化するには コードの内容をだんだん近づけていって 完全に一致したところでひとつにしよう  

#### Factory Method パターン
オブジェクトの作成に柔軟性を持たせたいとき コンストラクタで作るのではなく メソッドを使ってオブジェクトを作成する  
直接インスタンスを作るのではなく 間接的な役割をするメソッドを使うことで 異なるクラスのインスタンスを返せるようになる  
オブジェクトを作成するメソッドのことを Factory Method という  
Factory Method の短所は オブジェクトを作成するメソッドであることを覚えておく必要があること  
柔軟性が不要なら コンストラクタの方が良い  
気づき: 松岡さんの 『ドメイン駆動設計 サンプルコード & FAQ』 では コンストラクタをプライベートにして 気づくきっかけにするアイデアを提示していたなぁ  
